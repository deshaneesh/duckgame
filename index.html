<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Duck Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: Arial, sans-serif;
        }
        #gameCanvas {
            background: #87CEEB;
            display: none;  /* Hide canvas initially */
            width: 100%;
            height: 100%;
            touch-action: none;  /* Prevent default touch actions */
        }
        #scoreBar {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 20px;
            color: white;
            font-size: 24px;
            font-family: Arial, sans-serif;
            text-shadow: 2px 2px 0 #000;
            z-index: 1000;
            display: none;
        }
        #titleScreen {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: #87CEEB;
            color: #000;
            z-index: 100;
        }
        #gameTitle {
            font-size: 72px;
            margin-bottom: 40px;
            text-shadow: 3px 3px 0 #fff;
            animation: bounce 1s infinite;
        }
        #instructions {
            font-size: 24px;
            margin-bottom: 30px;
            text-align: center;
            text-shadow: 2px 2px 0 #fff;
        }
        #startButton {
            padding: 20px 40px;
            font-size: 24px;
            background: #FFD700;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s;
        }
        #startButton:hover {
            transform: scale(1.1);
        }
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }
        #mobileControls {
            position: fixed;
            bottom: 20px;
            left: 0;
            right: 0;
            display: none;
            justify-content: center;
            align-items: center;
            gap: 20px;
            padding: 0 20px;
            z-index: 1000;
        }
        #moveArea {
            width: 40%;
            height: 80px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 40px;
            position: relative;
        }
        #jumpButton {
            width: 120px;
            height: 120px;
            background: rgba(255, 215, 0, 0.7);
            border: 3px solid #FFD700;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: #000;
            user-select: none;
            -webkit-user-select: none;
            cursor: pointer;
            transition: transform 0.1s, background-color 0.1s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            margin: 0 auto;
        }
        #jumpButton:active {
            background: rgba(255, 215, 0, 0.9);
            transform: scale(0.95);
        }
        #deathScreen {
            position: absolute;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            z-index: 1000;
        }
        #deathTitle {
            font-size: 72px;
            margin-bottom: 20px;
            color: #ff0000;
            text-shadow: 3px 3px 0 #000;
        }
        #deathScore {
            font-size: 36px;
            margin-bottom: 20px;
            color: #fff;
            text-shadow: 2px 2px 0 #000;
        }
        #highScore {
            font-size: 24px;
            margin-bottom: 30px;
            color: #ffd700;
            text-shadow: 2px 2px 0 #000;
        }
        #restartButton {
            padding: 20px 40px;
            font-size: 24px;
            background: #ff0000;
            border: none;
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
            transition: transform 0.2s;
        }
        #restartButton:hover {
            transform: scale(1.1);
        }
        #healthBar {
            position: fixed;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 20px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            z-index: 1000;
            display: none;
        }
        #healthFill {
            width: 100%;
            height: 100%;
            background: #00ff00;
            border-radius: 10px;
            transition: width 0.3s, background-color 0.3s;
        }
        #healthText {
            position: absolute;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 14px;
            text-shadow: 1px 1px 0 #000;
            line-height: 20px;
        }
        #healthRegenIndicator {
            position: absolute;
            right: -25px;
            top: 0;
            color: #00ff00;
            font-size: 16px;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }
        /* Mobile and iPad specific styles */
        @media (max-width: 1024px) {
            #mobileControls {
                gap: 30px;
            }
            #moveArea {
                width: 45%;
                height: 100px;
            }
            #jumpButton {
                width: 150px;
                height: 150px;
                font-size: 36px;
                border-width: 4px;
            }
        }
        /* iPhone specific styles */
        @media (max-width: 428px) {
            #mobileControls {
                gap: 20px;
            }
            #moveArea {
                width: 40%;
                height: 90px;
            }
            #jumpButton {
                width: 130px;
                height: 130px;
                font-size: 32px;
            }
        }
        /* iPad specific styles */
        @media (min-width: 768px) and (max-width: 1024px) {
            #mobileControls {
                gap: 40px;
            }
            #moveArea {
                width: 50%;
                height: 120px;
            }
            #jumpButton {
                width: 180px;
                height: 180px;
                font-size: 42px;
                border-width: 5px;
            }
        }
    </style>
</head>
<body>
    <div id="titleScreen">
        <h1 id="gameTitle">Duck Game</h1>
        <div id="instructions">
            Press SPACE or W to jump<br>
            Hold SPACE for consecutive jumps<br>
            <span id="mobileInstructions" style="display: none;">
                Use the joystick to move<br>
                Tap the yellow button to jump
            </span>
        </div>
        <button id="startButton">Start Game</button>
    </div>
    <div id="deathScreen">
        <h1 id="deathTitle">Game Over!</h1>
        <div id="deathScore">Distance: 0m</div>
        <div id="highScore">High Score: 0m</div>
        <button id="restartButton">Play Again</button>
    </div>
    <div id="scoreBar">Distance: 0m</div>
    <div id="healthBar">
        <div id="healthFill"></div>
        <div id="healthText">100 HP</div>
        <div id="healthRegenIndicator">+</div>
    </div>
    <div id="mobileControls">
        <div id="moveArea">
            <div id="moveKnob"></div>
        </div>
        <div id="jumpButton">JUMP</div>
    </div>
    <canvas id="gameCanvas"></canvas>
    <script>
        // Initialize canvas
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const titleScreen = document.getElementById('titleScreen');
        const startButton = document.getElementById('startButton');

        // Game state
        const game = {
            running: false,
            score: 0,
            highScore: localStorage.getItem('highScore') || 0,
            lastFrameTime: 0,
            frameCount: 0,
            isResetting: false,
            secretKeys: [],
            secretCooldowns: {},
            activeEffects: [],
            health: 100,
            maxHealth: 100,
            invulnerable: false,
            invulnerabilityTime: 0,
            lastRegenTime: 0,
            regenInterval: 2000, // 2 seconds between regen ticks
            regenAmount: 1, // 1 HP per tick
            healthPotions: [],
            lastDamageTime: 0,
            damageCooldown: 10000, // 10 seconds cooldown before regen starts
            scoreMultiplier: 1,
            isGameOver: false
        };

        // Visual effects for shortcuts
        const EFFECT_COLORS = {
            superJump: 'rgba(0, 255, 255, 0.5)',  // Cyan
            speedBoost: 'rgba(255, 255, 0, 0.5)',  // Yellow
            doubleJump: 'rgba(0, 255, 0, 0.5)',  // Green
            wallJump: 'rgba(255, 165, 0, 0.5)',  // Orange
            timeSlow: 'rgba(128, 0, 128, 0.5)',  // Purple
            floatMode: 'rgba(135, 206, 235, 0.5)',  // Sky Blue
            heavyMode: 'rgba(139, 69, 19, 0.5)',  // Brown
            reverseControls: 'rgba(255, 0, 0, 0.5)',  // Red
            platformSize: 'rgba(255, 192, 203, 0.5)',  // Pink
            noSpikes: 'rgba(255, 255, 255, 0.5)',  // White
            // New effect colors
            rainbowMode: 'rgba(255, 0, 255, 0.5)',  // Magenta
            ghostMode: 'rgba(200, 200, 200, 0.5)',  // Gray
            tinyMode: 'rgba(0, 0, 255, 0.5)',  // Blue
            giantMode: 'rgba(255, 0, 0, 0.5)',  // Red
            bouncyMode: 'rgba(255, 165, 0, 0.5)',  // Orange
            stickyMode: 'rgba(128, 0, 128, 0.5)',  // Purple
            magnetMode: 'rgba(255, 215, 0, 0.5)',  // Gold
            shieldMode: 'rgba(0, 255, 255, 0.5)',  // Cyan
            doublePoints: 'rgba(255, 255, 0, 0.5)',  // Yellow
            timeWarp: 'rgba(255, 0, 255, 0.5)'  // Magenta
        };

        // Secret shortcuts
        const SECRET_COMBINATIONS = {
            'ArrowUpArrowUpArrowDownArrowDownArrowLeftArrowRightArrowLeftArrowRight': () => {
                // Konami code - Super jump
                if (!game.secretCooldowns.superJump) {
                    duck.speedY = JUMP_FORCE * 2;
                    game.secretCooldowns.superJump = true;
                    game.activeEffects.push('superJump');
                    setTimeout(() => {
                        game.secretCooldowns.superJump = false;
                        game.activeEffects = game.activeEffects.filter(effect => effect !== 'superJump');
                    }, 5000);
                }
            },
            'ShiftShift': () => {
                // Double Shift - Speed boost
                if (!game.secretCooldowns.speedBoost) {
                    duck.speedBoostEndTime = performance.now() + 30000;
                    duck.isSpeedBoosted = true;
                    game.secretCooldowns.speedBoost = true;
                    game.activeEffects.push('speedBoost');
                    setTimeout(() => {
                        game.secretCooldowns.speedBoost = false;
                        game.activeEffects = game.activeEffects.filter(effect => effect !== 'speedBoost');
                    }, 10000);
                }
            },
            'ArrowUpArrowDownArrowUpArrowDown': () => {
                // Up Down Up Down - Double jump
                if (!game.secretCooldowns.doubleJump) {
                    game.secretCooldowns.doubleJump = true;
                    const originalJumpForce = JUMP_FORCE;
                    JUMP_FORCE *= 1.5;
                    game.activeEffects.push('doubleJump');
                    setTimeout(() => {
                        JUMP_FORCE = originalJumpForce;
                        game.secretCooldowns.doubleJump = false;
                        game.activeEffects = game.activeEffects.filter(effect => effect !== 'doubleJump');
                    }, 10000);
                }
            },
            'ArrowLeftArrowRightArrowLeftArrowRight': () => {
                // Left Right Left Right - Wall jump
                if (!game.secretCooldowns.wallJump) {
                    game.secretCooldowns.wallJump = true;
                    const originalFriction = FRICTION;
                    FRICTION = 0.95;
                    game.activeEffects.push('wallJump');
                    setTimeout(() => {
                        FRICTION = originalFriction;
                        game.secretCooldowns.wallJump = false;
                        game.activeEffects = game.activeEffects.filter(effect => effect !== 'wallJump');
                    }, 15000);
                }
            },
            'SpaceSpaceSpace': () => {
                // Triple Space - Time slow
                if (!game.secretCooldowns.timeSlow) {
                    game.secretCooldowns.timeSlow = true;
                    const originalMoveSpeed = MOVE_SPEED;
                    const originalHardMoveSpeed = HARD_MOVE_SPEED;
                    const originalExtremeMoveSpeed = EXTREME_MOVE_SPEED;
                    MOVE_SPEED *= 0.5;
                    HARD_MOVE_SPEED *= 0.5;
                    EXTREME_MOVE_SPEED *= 0.5;
                    game.activeEffects.push('timeSlow');
                    setTimeout(() => {
                        MOVE_SPEED = originalMoveSpeed;
                        HARD_MOVE_SPEED = originalHardMoveSpeed;
                        EXTREME_MOVE_SPEED = originalExtremeMoveSpeed;
                        game.secretCooldowns.timeSlow = false;
                        game.activeEffects = game.activeEffects.filter(effect => effect !== 'timeSlow');
                    }, 8000);
                }
            },
            'ArrowUpArrowUpArrowUp': () => {
                // Triple Up - Float mode
                if (!game.secretCooldowns.floatMode) {
                    game.secretCooldowns.floatMode = true;
                    const originalGravity = GRAVITY;
                    GRAVITY = 0.1;
                    game.activeEffects.push('floatMode');
                    setTimeout(() => {
                        GRAVITY = originalGravity;
                        game.secretCooldowns.floatMode = false;
                        game.activeEffects = game.activeEffects.filter(effect => effect !== 'floatMode');
                    }, 12000);
                }
            },
            'ArrowDownArrowDownArrowDown': () => {
                // Triple Down - Heavy mode
                if (!game.secretCooldowns.heavyMode) {
                    game.secretCooldowns.heavyMode = true;
                    const originalGravity = GRAVITY;
                    GRAVITY = 0.8;
                    game.activeEffects.push('heavyMode');
                    setTimeout(() => {
                        GRAVITY = originalGravity;
                        game.secretCooldowns.heavyMode = false;
                        game.activeEffects = game.activeEffects.filter(effect => effect !== 'heavyMode');
                    }, 12000);
                }
            },
            'ArrowLeftArrowLeftArrowLeft': () => {
                // Triple Left - Reverse controls
                if (!game.secretCooldowns.reverseControls) {
                    game.secretCooldowns.reverseControls = true;
                    const originalRight = controls.right;
                    const originalLeft = controls.left;
                    controls.right = originalLeft;
                    controls.left = originalRight;
                    game.activeEffects.push('reverseControls');
                    setTimeout(() => {
                        controls.right = originalRight;
                        controls.left = originalLeft;
                        game.secretCooldowns.reverseControls = false;
                        game.activeEffects = game.activeEffects.filter(effect => effect !== 'reverseControls');
                    }, 15000);
                }
            },
            'ArrowRightArrowRightArrowRight': () => {
                // Triple Right - Platform size change
                if (!game.secretCooldowns.platformSize) {
                    game.secretCooldowns.platformSize = true;
                    const originalPlatformWidth = PLATFORM_WIDTH;
                    const originalHardPlatformWidth = HARD_PLATFORM_WIDTH;
                    PLATFORM_WIDTH *= 1.5;
                    HARD_PLATFORM_WIDTH *= 1.5;
                    game.activeEffects.push('platformSize');
                    setTimeout(() => {
                        PLATFORM_WIDTH = originalPlatformWidth;
                        HARD_PLATFORM_WIDTH = originalHardPlatformWidth;
                        game.secretCooldowns.platformSize = false;
                        game.activeEffects = game.activeEffects.filter(effect => effect !== 'platformSize');
                    }, 20000);
                }
            },
            'ShiftControl': () => {
                // Shift+Control - No spikes
                if (!game.secretCooldowns.noSpikes) {
                    game.secretCooldowns.noSpikes = true;
                    const originalSpikeChance = SPIKE_CHANCE;
                    const originalHardSpikeChance = HARD_SPIKE_CHANCE;
                    SPIKE_CHANCE = 0;
                    HARD_SPIKE_CHANCE = 0;
                    game.activeEffects.push('noSpikes');
                    setTimeout(() => {
                        SPIKE_CHANCE = originalSpikeChance;
                        HARD_SPIKE_CHANCE = originalHardSpikeChance;
                        game.secretCooldowns.noSpikes = false;
                        game.activeEffects = game.activeEffects.filter(effect => effect !== 'noSpikes');
                    }, 25000);
                }
            }
        };

        // Cloud types and probabilities
        const CLOUD_TYPES = {
            normal: { probability: 0.50, color: 'rgba(255, 255, 255, 0.8)' },
            thunder: { probability: 0.05, color: 'rgba(100, 100, 100, 0.9)' },
            rain: { probability: 0.25, color: 'rgba(200, 200, 200, 0.7)' },
            none: { probability: 0.20, color: null }
        };

        // Mountain types and probabilities
        const MOUNTAIN_TYPES = {
            normal: { probability: 0.50, color: 'rgba(139, 69, 19, 0.7)' },
            volcano: { probability: 0.05, color: 'rgba(139, 0, 0, 0.8)' },
            none: { probability: 0.20, color: null },
            snowy: { probability: 0.25, color: 'rgba(255, 255, 255, 0.9)' }
        };

        // Sun types and probabilities
        const SUN_TYPES = {
            normal: { probability: 0.99, color: '#FFD700', radius: 60 },
            supernova: { probability: 0.01, color: '#FF4500', radius: 100 }
        };

        // Add mountains and sun
        const mountains = [];
        const MOUNTAIN_COUNT = 5;
        const SUN = {
            x: 0,
            y: 0,
            type: getRandomType(SUN_TYPES)
        };

        function getRandomType(types) {
            const rand = Math.random();
            let cumulative = 0;
            for (const [type, data] of Object.entries(types)) {
                cumulative += data.probability;
                if (rand <= cumulative) return type;
            }
            return Object.keys(types)[0];
        }

        function initMountains() {
            for (let i = 0; i < MOUNTAIN_COUNT; i++) {
                const mountainType = getRandomType(MOUNTAIN_TYPES);
                if (mountainType === 'none') continue;

                const mountainData = MOUNTAIN_TYPES[mountainType];
                mountains.push({
                    x: Math.random() * canvas.width * 2,
                    y: canvas.height - 100,
                    width: 200 + Math.random() * 300,
                    height: 150 + Math.random() * 200,
                    type: mountainType,
                    color: mountainData.color
                });
            }
        }

        function drawMountains() {
            for (const mountain of mountains) {
                if (!mountain.color) continue;

                ctx.fillStyle = mountain.color;
                ctx.beginPath();
                ctx.moveTo(mountain.x, mountain.y);
                ctx.lineTo(mountain.x + mountain.width/2, mountain.y - mountain.height);
                ctx.lineTo(mountain.x + mountain.width, mountain.y);
                ctx.fill();

                // Add effects based on mountain type
                if (mountain.type === 'volcano') {
                    // Draw lava
                    ctx.fillStyle = 'rgba(255, 69, 0, 0.6)';
                    ctx.beginPath();
                    ctx.moveTo(mountain.x + mountain.width/2, mountain.y - mountain.height);
                    ctx.lineTo(mountain.x + mountain.width/2 - 20, mountain.y - mountain.height + 30);
                    ctx.lineTo(mountain.x + mountain.width/2 + 20, mountain.y - mountain.height + 30);
                    ctx.fill();
                } else if (mountain.type === 'snowy') {
                    // Draw snow cap
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.beginPath();
                    ctx.moveTo(mountain.x + mountain.width/2 - 30, mountain.y - mountain.height + 20);
                    ctx.lineTo(mountain.x + mountain.width/2, mountain.y - mountain.height);
                    ctx.lineTo(mountain.x + mountain.width/2 + 30, mountain.y - mountain.height + 20);
                    ctx.fill();
                }
            }
        }

        function drawSun() {
            const sunData = SUN_TYPES[SUN.type];
            ctx.fillStyle = sunData.color;
            ctx.beginPath();
            ctx.arc(SUN.x, SUN.y, sunData.radius, 0, Math.PI * 2);
            ctx.fill();

            // Add sun rays
            ctx.strokeStyle = sunData.color;
            ctx.lineWidth = 3;
            for (let i = 0; i < 8; i++) {
                const angle = (i * Math.PI) / 4;
                ctx.beginPath();
                ctx.moveTo(
                    SUN.x + Math.cos(angle) * sunData.radius,
                    SUN.y + Math.sin(angle) * sunData.radius
                );
                ctx.lineTo(
                    SUN.x + Math.cos(angle) * (sunData.radius + 20),
                    SUN.y + Math.sin(angle) * (sunData.radius + 20)
                );
                ctx.stroke();
            }

            // Add supernova effects
            if (SUN.type === 'supernova') {
                // Draw energy waves
                for (let i = 0; i < 3; i++) {
                    ctx.strokeStyle = `rgba(255, 69, 0, ${0.3 - i * 0.1})`;
                    ctx.lineWidth = 5 - i;
                    ctx.beginPath();
                    ctx.arc(SUN.x, SUN.y, sunData.radius + 30 + i * 20, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
        }

        // Update ground and mountain constants
        const GROUND = {
            y: canvas.height - 100, // Aligned with mountains
            height: 100,
            color: '#8B4513'
        };

        function drawGround() {
            ctx.fillStyle = GROUND.color;
            ctx.fillRect(0, GROUND.y, canvas.width, GROUND.height);
            
            // Add grass on top
            ctx.fillStyle = '#228B22';
            ctx.fillRect(0, GROUND.y, canvas.width, 10);
            
            // Add some texture
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 2;
            for (let i = 0; i < canvas.width; i += 30) {
                ctx.beginPath();
                ctx.moveTo(i, GROUND.y);
                ctx.lineTo(i, GROUND.y + GROUND.height);
                ctx.stroke();
            }
        }

        // Add new shortcuts
        const NEW_SECRET_COMBINATIONS = {
            'ArrowUpArrowDownArrowLeftArrowRight': function() {
                // Rainbow mode
                if (!game.secretCooldowns.rainbowMode) {
                    game.secretCooldowns.rainbowMode = true;
                    game.activeEffects.push('rainbowMode');
                    const originalColors = {
                        duck: '#FFD700',
                        beak: '#FFA500'
                    };
                    let hue = 0;
                    const rainbowInterval = setInterval(() => {
                        hue = (hue + 1) % 360;
                        duck.color = `hsl(${hue}, 100%, 50%)`;
                    }, 50);
                    setTimeout(() => {
                        clearInterval(rainbowInterval);
                        duck.color = originalColors.duck;
                        game.secretCooldowns.rainbowMode = false;
                        game.activeEffects = game.activeEffects.filter(effect => effect !== 'rainbowMode');
                    }, 15000);
                }
            },
            'ArrowDownArrowUpArrowRightArrowLeft': function() {
                // Ghost mode
                if (!game.secretCooldowns.ghostMode) {
                    game.secretCooldowns.ghostMode = true;
                    game.activeEffects.push('ghostMode');
                    duck.ghostMode = true;
                    setTimeout(() => {
                        duck.ghostMode = false;
                        game.secretCooldowns.ghostMode = false;
                        game.activeEffects = game.activeEffects.filter(effect => effect !== 'ghostMode');
                    }, 10000);
                }
            },
            'ArrowLeftArrowRightArrowUpArrowDown': function() {
                // Tiny mode
                if (!game.secretCooldowns.tinyMode) {
                    game.secretCooldowns.tinyMode = true;
                    game.activeEffects.push('tinyMode');
                    const originalSize = { width: duck.width, height: duck.height };
                    duck.width = originalSize.width * 0.5;
                    duck.height = originalSize.height * 0.5;
                    setTimeout(() => {
                        duck.width = originalSize.width;
                        duck.height = originalSize.height;
                        game.secretCooldowns.tinyMode = false;
                        game.activeEffects = game.activeEffects.filter(effect => effect !== 'tinyMode');
                    }, 12000);
                }
            },
            'ArrowRightArrowLeftArrowDownArrowUp': function() {
                // Giant mode
                if (!game.secretCooldowns.giantMode) {
                    game.secretCooldowns.giantMode = true;
                    game.activeEffects.push('giantMode');
                    const originalSize = { width: duck.width, height: duck.height };
                    duck.width = originalSize.width * 2;
                    duck.height = originalSize.height * 2;
                    setTimeout(() => {
                        duck.width = originalSize.width;
                        duck.height = originalSize.height;
                        game.secretCooldowns.giantMode = false;
                        game.activeEffects = game.activeEffects.filter(effect => effect !== 'giantMode');
                    }, 12000);
                }
            },
            'SpaceSpaceArrowUpArrowUp': function() {
                // Bouncy mode
                if (!game.secretCooldowns.bouncyMode) {
                    game.secretCooldowns.bouncyMode = true;
                    game.activeEffects.push('bouncyMode');
                    const originalJumpForce = JUMP_FORCE;
                    JUMP_FORCE *= 1.5;
                    setTimeout(() => {
                        JUMP_FORCE = originalJumpForce;
                        game.secretCooldowns.bouncyMode = false;
                        game.activeEffects = game.activeEffects.filter(effect => effect !== 'bouncyMode');
                    }, 15000);
                }
            },
            'ArrowUpArrowUpSpaceSpace': function() {
                // Sticky mode
                if (!game.secretCooldowns.stickyMode) {
                    game.secretCooldowns.stickyMode = true;
                    game.activeEffects.push('stickyMode');
                    const originalFriction = FRICTION;
                    FRICTION = 0.95;
                    setTimeout(() => {
                        FRICTION = originalFriction;
                        game.secretCooldowns.stickyMode = false;
                        game.activeEffects = game.activeEffects.filter(effect => effect !== 'stickyMode');
                    }, 15000);
                }
            },
            'ArrowLeftArrowRightSpaceSpace': function() {
                // Magnet mode
                if (!game.secretCooldowns.magnetMode) {
                    game.secretCooldowns.magnetMode = true;
                    game.activeEffects.push('magnetMode');
                    const originalSpawnChance = HEALTH_POTION.spawnChance;
                    HEALTH_POTION.spawnChance = 0.3;
                    setTimeout(() => {
                        HEALTH_POTION.spawnChance = originalSpawnChance;
                        game.secretCooldowns.magnetMode = false;
                        game.activeEffects = game.activeEffects.filter(effect => effect !== 'magnetMode');
                    }, 20000);
                }
            },
            'SpaceSpaceArrowLeftArrowRight': function() {
                // Shield mode
                if (!game.secretCooldowns.shieldMode) {
                    game.secretCooldowns.shieldMode = true;
                    game.activeEffects.push('shieldMode');
                    const originalInvulnerabilityTime = game.invulnerabilityTime;
                    game.invulnerabilityTime = performance.now() + 15000;
                    setTimeout(() => {
                        game.invulnerabilityTime = originalInvulnerabilityTime;
                        game.secretCooldowns.shieldMode = false;
                        game.activeEffects = game.activeEffects.filter(effect => effect !== 'shieldMode');
                    }, 15000);
                }
            },
            'ArrowUpArrowDownSpaceSpace': function() {
                // Double points
                if (!game.secretCooldowns.doublePoints) {
                    game.secretCooldowns.doublePoints = true;
                    game.activeEffects.push('doublePoints');
                    const originalScoreMultiplier = 1;
                    game.scoreMultiplier = 2;
                    setTimeout(() => {
                        game.scoreMultiplier = originalScoreMultiplier;
                        game.secretCooldowns.doublePoints = false;
                        game.activeEffects = game.activeEffects.filter(effect => effect !== 'doublePoints');
                    }, 30000);
                }
            },
            'SpaceSpaceArrowDownArrowUp': function() {
                // Time warp
                if (!game.secretCooldowns.timeWarp) {
                    game.secretCooldowns.timeWarp = true;
                    game.activeEffects.push('timeWarp');
                    const originalMoveSpeed = MOVE_SPEED;
                    const originalHardMoveSpeed = HARD_MOVE_SPEED;
                    const originalExtremeMoveSpeed = EXTREME_MOVE_SPEED;
                    MOVE_SPEED *= 2;
                    HARD_MOVE_SPEED *= 2;
                    EXTREME_MOVE_SPEED *= 2;
                    setTimeout(() => {
                        MOVE_SPEED = originalMoveSpeed;
                        HARD_MOVE_SPEED = originalHardMoveSpeed;
                        EXTREME_MOVE_SPEED = originalExtremeMoveSpeed;
                        game.secretCooldowns.timeWarp = false;
                        game.activeEffects = game.activeEffects.filter(effect => effect !== 'timeWarp');
                    }, 10000);
                }
            }
        };

        // Merge new shortcuts with existing ones
        Object.assign(SECRET_COMBINATIONS, NEW_SECRET_COMBINATIONS);

        // Mobile controls
        const mobileControls = document.getElementById('mobileControls');
        const moveArea = document.getElementById('moveArea');
        const moveKnob = document.getElementById('moveKnob');
        const jumpButton = document.getElementById('jumpButton');
        const mobileInstructions = document.getElementById('mobileInstructions');
        let isMobile = false;

        // Check if device is mobile
        function checkMobile() {
            isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            if (isMobile) {
                mobileInstructions.style.display = 'block';
                mobileControls.style.display = 'flex';
            }
        }

        // Mobile touch controls
        let moveKnobActive = false;
        let moveKnobStartX = 0;
        let moveKnobStartY = 0;
        let moveKnobCurrentX = 0;

        moveKnob.addEventListener('touchstart', (e) => {
            e.preventDefault();
            moveKnobActive = true;
            const touch = e.touches[0];
            moveKnobStartX = touch.clientX;
            moveKnobStartY = touch.clientY;
            moveKnobCurrentX = moveKnob.offsetLeft;
        });

        document.addEventListener('touchmove', (e) => {
            if (!moveKnobActive) return;
            e.preventDefault();
            const touch = e.touches[0];
            const deltaX = touch.clientX - moveKnobStartX;
            const newX = Math.max(0, Math.min(moveArea.offsetWidth - moveKnob.offsetWidth, moveKnobCurrentX + deltaX));
            moveKnob.style.left = newX + 'px';
            
            // Update controls based on knob position
            const center = moveArea.offsetWidth / 2;
            const moveAmount = (newX - center) / center;
            controls.left = moveAmount < -0.2;
            controls.right = moveAmount > 0.2;
        });

        document.addEventListener('touchend', () => {
            moveKnobActive = false;
            moveKnob.style.left = '50%';
            moveKnob.style.transform = 'translateX(-50%)';
            controls.left = false;
            controls.right = false;
        });

        jumpButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            controls.jump = true;
        });

        jumpButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            controls.jump = false;
        });

        // Prevent default touch behaviors
        document.addEventListener('touchmove', (e) => {
            if (e.target === canvas || e.target === moveArea || e.target === moveKnob || e.target === jumpButton) {
                e.preventDefault();
            }
        }, { passive: false });

        // Start game function
        function startGame() {
            titleScreen.style.display = 'none';
            canvas.style.display = 'block';
            document.getElementById('scoreBar').style.display = 'block';
            document.getElementById('healthBar').style.display = 'block';
            if (isMobile) {
                mobileControls.style.display = 'flex';
            }
            game.running = true;
            game.health = game.maxHealth;
            updateHealthBar();
            resetPlayer();
            requestAnimationFrame(gameLoop);
        }

        // Add click event to start button
        startButton.addEventListener('click', startGame);

        // Add space/enter key to start game
        document.addEventListener('keydown', (e) => {
            if (!game.running && (e.key === ' ' || e.key === 'Enter')) {
                startGame();
            }
        });

        // Set canvas size
        function setCanvasSize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        // Initial setup
        setCanvasSize();
        window.addEventListener('resize', setCanvasSize);

        // Game objects
        const duck = {
            x: 100,
            y: 100,
            width: 50,
            height: 50,
            speedX: 0,
            speedY: 0,
            onGround: false,
            facingRight: true,
            autoMove: true,
            startX: 100,
            startY: 100,
            jumpQueued: false,
            speedBoostEndTime: 0,
            isSpeedBoosted: false,
            color: '#FFD700'
        };

        const camera = {
            x: 0,
            y: 0,
            lerp: 0.1
        };

        const platforms = [];
        const PLATFORM_SPACING = 180;
        const PLATFORM_WIDTH = 150;
        const PLATFORM_HEIGHT = 30;
        const PLATFORM_MIN_Y = 200;
        const PLATFORM_MAX_Y = 500;
        const MAX_JUMP_DISTANCE = 250;
        const MIN_JUMP_DISTANCE = 50;
        const SAFE_JUMP_MARGIN = 0.7; // 70% of max jump height for safety
        const SPIKE_START_DISTANCE = 2000;
        const SPIKE_CHANCE = 0.3;
        const HARD_SPIKE_CHANCE = 0.5;
        const SPIKE_WIDTH = 20;
        const SPIKE_HEIGHT = 15;
        const SPIKE_OFFSET = 65;
        const HARD_MODE_START = 100000;  // 1000m
        const HARD_PLATFORM_WIDTH = 120;
        const HARD_MOVE_SPEED = 14;
        const SPEED_BOOST_CHANCE = 0.15;
        const HARD_SPEED_BOOST_CHANCE = 0.25;
        const EXTREME_MODE_START = 10000000;  // 100000m
        const EXTREME_SPEED_BOOST_CHANCE = 0.4;
        const EXTREME_MOVE_SPEED = 18;
        const EXTREME_PLATFORM_WIDTH = 100;
        const ULTIMATE_MODE_START = 1000000000;  // 1 billion meters
        const ULTIMATE_MOVE_SPEED = 35;  // Reduced from 50 to 35
        const ULTIMATE_PLATFORM_WIDTH = 50;  // Increased from 30 to 50
        const ULTIMATE_SPIKE_CHANCE = 0.6;  // Reduced from 0.8 to 0.6
        const ULTIMATE_SPEED_BOOST_CHANCE = 0.4;  // Reduced from 0.6 to 0.4
        const SPEED_BOOST_DURATION = 10000;
        const SPEED_BOOST_MULTIPLIER = 2;
        const SPEED_BOOST_JUMP_MULTIPLIER = 0.5;

        // Game constants
        const GRAVITY = 0.4;
        const JUMP_FORCE = -10;
        const MOVE_SPEED = 10;
        const FRICTION = 0.85;

        // Controls
        const controls = {
            right: false,
            left: false,
            jump: false
        };

        // Spike types with damage values
        const SPIKE_TYPES = {
            normal: {
                color: '#FF0000',
                width: 20,
                height: 15,
                damage: 10,
                effect: null
            },
            fire: {
                color: '#FF4500',
                width: 25,
                height: 20,
                damage: 20,
                effect: 'burn'
            },
            ice: {
                color: '#00FFFF',
                width: 18,
                height: 18,
                damage: 15,
                effect: 'freeze'
            },
            poison: {
                color: '#32CD32',
                width: 22,
                height: 16,
                damage: 5,
                effect: 'poison'
            }
        };

        // Health potion properties
        const HEALTH_POTION = {
            width: 20,
            height: 30,
            healAmount: 25,
            spawnChance: 0.1, // 10% chance per platform
            color: '#ff00ff'
        };

        // Event listeners
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowRight':
                case 'd':
                    controls.right = true;
                    break;
                case 'ArrowLeft':
                case 'a':
                    controls.left = true;
                    break;
                case 'ArrowUp':
                case 'w':
                case ' ':
                    controls.jump = true;
                    break;
                case 'Backspace':
                case '1':
                    resetPlayer();
                    break;
            }

            // Add key to sequence for other combinations
            game.secretKeys.push(e.key);
            
            // Keep only last 10 keys
            if (game.secretKeys.length > 10) {
                game.secretKeys.shift();
            }
            
            // Check for other secret combinations
            const currentSequence = game.secretKeys.join('');
            for (const [combination, action] of Object.entries(SECRET_COMBINATIONS)) {
                if (currentSequence.endsWith(combination)) {
                    action();
                    game.secretKeys = [];  // Reset sequence after successful combination
                    break;
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            switch(e.key) {
                case 'ArrowRight':
                case 'd':
                    controls.right = false;
                    break;
                case 'ArrowLeft':
                case 'a':
                    controls.left = false;
                    break;
                case 'ArrowUp':
                case 'w':
                case ' ':
                    controls.jump = false;
                    break;
            }
        });

        // Initialize platforms
        function initPlatforms() {
            try {
                platforms.length = 0;

                // Initial platform
                platforms.push({
                    x: duck.startX - PLATFORM_WIDTH/2,
                    y: duck.startY + 50,
                    width: PLATFORM_WIDTH,
                    height: PLATFORM_HEIGHT,
                    type: 'normal',
                    hasSpikes: false,
                    spikeX: 0
                });

                // Generate initial platforms
                generatePlatforms(8);
            } catch (error) {
                console.error('Error initializing platforms:', error);
                resetPlayer();
            }
        }

        // Simplified platform generation
        function generatePlatforms(count) {
            try {
                const lastPlatform = platforms[platforms.length - 1];
                if (!lastPlatform) return;

                let lastX = lastPlatform.x + PLATFORM_SPACING;
                const screenRightEdge = camera.x + canvas.width + PLATFORM_SPACING * 2;

                for (let i = 0; i < count; i++) {
                    if (lastX > screenRightEdge) break;

                    // Simple Y calculation
                    const y = Math.random() * (PLATFORM_MAX_Y - PLATFORM_MIN_Y) + PLATFORM_MIN_Y;

                    const isHardMode = lastX > HARD_MODE_START;
                    const isExtremeMode = lastX > EXTREME_MODE_START;
                    const isUltimateMode = lastX > ULTIMATE_MODE_START;
                    
                    // Platform type
                    let platformType = 'normal';
                    if (isHardMode && Math.random() < (isUltimateMode ? ULTIMATE_SPEED_BOOST_CHANCE : 
                                                      (isExtremeMode ? EXTREME_SPEED_BOOST_CHANCE : 
                                                      HARD_SPEED_BOOST_CHANCE))) {
                        platformType = 'speedboost';
                    }
                    
                    // Spikes
                    let hasSpikes = false;
                    if (isUltimateMode) {
                        hasSpikes = platformType === 'normal' && Math.random() < ULTIMATE_SPIKE_CHANCE;
                    } else if (isHardMode) {
                        hasSpikes = platformType === 'normal';
                    } else {
                        hasSpikes = lastX > SPIKE_START_DISTANCE && Math.random() < SPIKE_CHANCE;
                    }
                    
                    // Platform width
                    const platformWidth = isUltimateMode ? ULTIMATE_PLATFORM_WIDTH :
                                        (isExtremeMode ? EXTREME_PLATFORM_WIDTH :
                                        (isHardMode ? HARD_PLATFORM_WIDTH : PLATFORM_WIDTH));
                    
                    // Spike position
                    const spikeX = lastX + (isHardMode ? platformWidth/2 - SPIKE_WIDTH/2 : SPIKE_OFFSET);
                    
                    // Spike type
                    let spikeType = 'normal';
                    if (isUltimateMode) {
                        const rand = Math.random();
                        if (rand < 0.75) spikeType = 'fire';
                        else if (rand < 0.85) spikeType = 'poison';
                        else spikeType = 'ice';
                    } else if (isExtremeMode) {
                        const rand = Math.random();
                        if (rand < 0.05) spikeType = 'normal';
                        else if (rand < 0.55) spikeType = 'fire';
                        else if (rand < 0.80) spikeType = 'ice';
                        else spikeType = 'poison';
                    } else if (isHardMode) {
                        const rand = Math.random();
                        if (rand < 0.35) spikeType = 'normal';
                        else if (rand < 0.50) spikeType = 'fire';
                        else if (rand < 0.75) spikeType = 'poison';
                        else spikeType = 'ice';
                    } else {
                        const rand = Math.random();
                        if (rand < 0.50) spikeType = 'normal';
                        else if (rand < 0.55) spikeType = 'fire';
                        else if (rand < 0.90) spikeType = 'poison';
                        else spikeType = 'ice';
                    }

                    // Health potion
                    if (Math.random() < HEALTH_POTION.spawnChance) {
                        game.healthPotions.push({
                            x: lastX + platformWidth/2 - HEALTH_POTION.width/2,
                            y: y - HEALTH_POTION.height,
                            width: HEALTH_POTION.width,
                            height: HEALTH_POTION.height,
                            collected: false
                        });
                    }

                    // Add platform
                    platforms.push({
                        x: lastX,
                        y: y,
                        width: platformWidth,
                        height: PLATFORM_HEIGHT,
                        type: platformType,
                        hasSpikes: hasSpikes,
                        spikeType: spikeType,
                        spikeX: spikeX,
                        isExtremeMode: isExtremeMode,
                        isUltimateMode: isUltimateMode
                    });

                    lastX += PLATFORM_SPACING;
                }

                // Clean up old platforms
                const cleanupThreshold = camera.x - PLATFORM_SPACING;
                platforms = platforms.filter(platform => platform.x > cleanupThreshold);
                game.healthPotions = game.healthPotions.filter(potion => 
                    potion.x > cleanupThreshold && !potion.collected
                );
            } catch (error) {
                console.error('Error generating platforms:', error);
            }
        }

        function resetPlayer() {
            if (game.isResetting) return;
            game.isResetting = true;

            try {
                // Reset duck position and state
                duck.x = duck.startX;
                duck.y = duck.startY;
                duck.speedX = 0;
                duck.speedY = 0;
                duck.jumpQueued = false;
                duck.speedBoostEndTime = 0;
                duck.isSpeedBoosted = false;
                duck.onGround = false;
                duck.facingRight = true;
                
                // Reset camera
                camera.x = 0;
                
                // Initialize platforms
                initPlatforms();

                // Reset game state
                game.lastFrameTime = performance.now();
                game.frameCount = 0;
                game.health = game.maxHealth;
                game.healthPotions = [];
                updateHealthBar();

                // Show death screen if game was running
                if (game.running) {
                    handleDeath();
                }
            } catch (error) {
                console.error('Error in resetPlayer:', error);
                window.location.reload();
            } finally {
                game.isResetting = false;
            }
        }

        // Add clouds
        const clouds = [];
        const CLOUD_COUNT = 10;
        const CLOUD_SPEED = 0.2;

        function initClouds() {
            for (let i = 0; i < CLOUD_COUNT; i++) {
                const cloudType = getRandomType(CLOUD_TYPES);
                if (cloudType === 'none') continue;

                clouds.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * (canvas.height / 2),
                    width: 60 + Math.random() * 40,
                    height: 30 + Math.random() * 20,
                    type: cloudType
                });
            }
        }

        function updateClouds() {
            for (const cloud of clouds) {
                cloud.x -= CLOUD_SPEED;
                if (cloud.x + cloud.width < 0) {
                    cloud.x = canvas.width;
                    cloud.y = Math.random() * (canvas.height / 2);
                }
            }
        }

        function drawCloud(x, y, width, height, type) {
            const cloudData = CLOUD_TYPES[type];
            if (!cloudData || !cloudData.color) return;

            ctx.fillStyle = cloudData.color;
            ctx.beginPath();
            ctx.arc(x, y, width/3, 0, Math.PI * 2);
            ctx.arc(x + width/3, y - height/4, width/4, 0, Math.PI * 2);
            ctx.arc(x + width/2, y, width/3, 0, Math.PI * 2);
            ctx.arc(x + width/3, y + height/4, width/4, 0, Math.PI * 2);
            ctx.fill();

            // Add effects based on cloud type
            if (type === 'thunder') {
                // Draw lightning
                if (Math.random() < 0.1) {
                    ctx.strokeStyle = '#FFFF00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x + width/2, y + height);
                    ctx.lineTo(x + width/2, y + height + 30);
                    ctx.stroke();
                }
            } else if (type === 'rain') {
                // Draw rain
                ctx.strokeStyle = 'rgba(200, 200, 255, 0.5)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 5; i++) {
                    const rainX = x + (width * i / 4);
                    ctx.beginPath();
                    ctx.moveTo(rainX, y + height);
                    ctx.lineTo(rainX - 5, y + height + 15);
                    ctx.stroke();
                }
            }
        }

        // Update health bar
        function updateHealthBar() {
            const healthBar = document.getElementById('healthBar');
            const healthFill = document.getElementById('healthFill');
            const healthText = document.getElementById('healthText');
            const healthRegenIndicator = document.getElementById('healthRegenIndicator');
            
            const healthPercent = (game.health / game.maxHealth) * 100;
            healthFill.style.width = `${healthPercent}%`;
            healthText.textContent = `${Math.ceil(game.health)} HP`;

            // Change color based on health
            if (healthPercent > 60) {
                healthFill.style.backgroundColor = '#00ff00';
            } else if (healthPercent > 30) {
                healthFill.style.backgroundColor = '#ffff00';
            } else {
                healthFill.style.backgroundColor = '#ff0000';
            }

            // Show/hide regen indicator only if not in damage cooldown
            const currentTime = performance.now();
            const canRegen = currentTime - game.lastDamageTime >= game.damageCooldown;
            healthRegenIndicator.style.display = (game.health < game.maxHealth && canRegen) ? 'block' : 'none';
        }

        // Heal function
        function heal(amount) {
            game.health = Math.min(game.maxHealth, game.health + amount);
            updateHealthBar();
        }

        // Take damage function
        function takeDamage(amount, effect = null) {
            if (game.invulnerable) return;
            
            game.health = Math.max(0, game.health - amount);
            game.lastDamageTime = performance.now(); // Update last damage time
            updateHealthBar();

            // Apply effects
            if (effect) {
                switch(effect) {
                    case 'burn':
                        // Take additional damage over time
                        let burnDamage = amount * 0.2;
                        for (let i = 0; i < 5; i++) {
                            setTimeout(() => {
                                game.health = Math.max(0, game.health - burnDamage);
                                game.lastDamageTime = performance.now(); // Update on each burn tick
                                updateHealthBar();
                            }, i * 1000);
                        }
                        break;
                    case 'freeze':
                        // Slow down movement temporarily
                        const originalMoveSpeed = MOVE_SPEED;
                        MOVE_SPEED *= 0.5;
                        setTimeout(() => {
                            MOVE_SPEED = originalMoveSpeed;
                        }, 3000);
                        break;
                    case 'poison':
                        // Take small damage over time
                        let poisonDamage = amount * 0.1;
                        for (let i = 0; i < 10; i++) {
                            setTimeout(() => {
                                game.health = Math.max(0, game.health - poisonDamage);
                                game.lastDamageTime = performance.now(); // Update on each poison tick
                                updateHealthBar();
                            }, i * 1000);
                        }
                        break;
                }
            }

            // Check for death
            if (game.health <= 0) {
                handleDeath();
                return;
            }

            // Temporary invulnerability
            game.invulnerable = true;
            game.invulnerabilityTime = performance.now() + 1000; // 1 second invulnerability
        }

        function update() {
            if (game.isResetting) return;

            try {
                const currentTime = performance.now();
                const deltaTime = currentTime - game.lastFrameTime;
                
                // Check for severe lag
                if (deltaTime > 100) {
                    console.warn('Severe lag detected, resetting...');
                    resetPlayer();
                    return;
                }

                game.lastFrameTime = currentTime;
                game.frameCount++;

                // Update clouds
                updateClouds();

                // Update score
                game.score = Math.floor(duck.x / 100);  // 1 point per 100 pixels
                document.getElementById('scoreBar').textContent = `Distance: ${game.score}m`;

                // Check if we're in hard mode, extreme mode, or ultimate mode
                const isHardMode = duck.x > HARD_MODE_START;
                const isExtremeMode = duck.x > EXTREME_MODE_START;
                const isUltimateMode = duck.x > ULTIMATE_MODE_START;
                let currentMoveSpeed = isUltimateMode ? ULTIMATE_MOVE_SPEED : 
                                     (isExtremeMode ? EXTREME_MOVE_SPEED : 
                                     (isHardMode ? HARD_MOVE_SPEED : MOVE_SPEED));

                // Update speed boost state
                if (currentTime > duck.speedBoostEndTime) {
                    duck.isSpeedBoosted = false;
                }

                // Apply speed boost if active
                if (duck.isSpeedBoosted) {
                    currentMoveSpeed *= SPEED_BOOST_MULTIPLIER;
                }

                // Movement
                if (duck.autoMove) {
                    duck.speedX = currentMoveSpeed;
                    duck.facingRight = true;
                } else {
                    if (controls.right) {
                        duck.speedX = currentMoveSpeed;
                        duck.facingRight = true;
                    } else if (controls.left) {
                        duck.speedX = -currentMoveSpeed;
                        duck.facingRight = false;
                    } else {
                        duck.speedX *= FRICTION;
                    }
                }

                // Jump handling
                if (controls.jump) {
                    duck.jumpQueued = true;
                }

                if (duck.jumpQueued && duck.onGround) {
                    const jumpForce = duck.isSpeedBoosted ? JUMP_FORCE * SPEED_BOOST_JUMP_MULTIPLIER : JUMP_FORCE;
                    duck.speedY = jumpForce;
                    duck.onGround = false;
                    duck.jumpQueued = false;
                }

                // Physics
                duck.speedY += GRAVITY;
                duck.x += duck.speedX;
                duck.y += duck.speedY;

                // Fall detection
                if (duck.y > canvas.height + 100) {
                    resetPlayer();
                    return;
                }

                // Check invulnerability
                if (game.invulnerable && performance.now() > game.invulnerabilityTime) {
                    game.invulnerable = false;
                }

                // Platform collision
                duck.onGround = false;
                for (const platform of platforms) {
                    if (!platform) continue;

                    // Check for spike collision
                    if (platform.hasSpikes) {
                        if (duck.x + duck.width > platform.spikeX &&
                            duck.x < platform.spikeX + SPIKE_TYPES[platform.spikeType].width &&
                            duck.y + duck.height > platform.y &&
                            duck.y + duck.height < platform.y + platform.height + 10) {
                            takeDamage(SPIKE_TYPES[platform.spikeType].damage, SPIKE_TYPES[platform.spikeType].effect);
                        }
                    }

                    // Regular platform collision
                    if (duck.x < platform.x + platform.width &&
                        duck.x + duck.width > platform.x &&
                        duck.y + duck.height > platform.y &&
                        duck.y < platform.y + platform.height) {
                        duck.onGround = true;
                        duck.y = platform.y - duck.height;
                        duck.speedY = 0;

                        // Activate speed boost if platform is speed boost type
                        if (platform.type === 'speedboost' && !duck.isSpeedBoosted) {
                            duck.speedBoostEndTime = currentTime + SPEED_BOOST_DURATION;
                            duck.isSpeedBoosted = true;
                        }
                    }
                }

                // Generate new platforms
                const lastPlatform = platforms[platforms.length - 1];
                if (lastPlatform && lastPlatform.x < camera.x + canvas.width + PLATFORM_SPACING) {
                    generatePlatforms(5);
                }

                // Camera update with faster smoothing
                const targetX = Math.max(0, duck.x - canvas.width / 3);
                camera.x += (targetX - camera.x) * 0.15;

                // Health regeneration with damage cooldown check
                if (currentTime - game.lastRegenTime >= game.regenInterval) {
                    if (game.health < game.maxHealth && 
                        currentTime - game.lastDamageTime >= game.damageCooldown) {
                        heal(game.regenAmount);
                    }
                    game.lastRegenTime = currentTime;
                }

                // Check for potion collection
                for (const potion of game.healthPotions) {
                    if (!potion.collected &&
                        duck.x < potion.x + potion.width &&
                        duck.x + duck.width > potion.x &&
                        duck.y < potion.y + potion.height &&
                        duck.y + duck.height > potion.y) {
                        potion.collected = true;
                        heal(HEALTH_POTION.healAmount);
                    }
                }

            } catch (error) {
                console.error('Error in update:', error);
                resetPlayer();
            }
        }

        function draw() {
            if (game.isResetting) return;

            try {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw sun
                SUN.x = canvas.width - 100;
                SUN.y = 100;
                drawSun();

                // Draw mountains
                drawMountains();

                // Draw ground
                drawGround();

                // Draw clouds
                for (const cloud of clouds) {
                    drawCloud(cloud.x, cloud.y, cloud.width, cloud.height, cloud.type);
                }

                ctx.save();
                ctx.translate(-camera.x, 0);

                // Draw platforms
                for (const platform of platforms) {
                    if (!platform) continue;

                    // Only draw platforms that are visible
                    if (platform.x + platform.width < camera.x || platform.x > camera.x + canvas.width) {
                        continue;
                    }

                    // Draw platform
                    if (platform.type === 'speedboost') {
                        ctx.fillStyle = '#000000';
                    } else {
                        ctx.fillStyle = '#8B4513';
                    }
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);

                    // Draw spikes if platform has them
                    if (platform.hasSpikes) {
                        const spikeType = SPIKE_TYPES[platform.spikeType];
                        ctx.fillStyle = spikeType.color;
                        const spikeX = platform.spikeX;
                        
                        // Draw spike based on type
                        switch(platform.spikeType) {
                            case 'fire':
                                // Draw flame-like spike
                                ctx.beginPath();
                                ctx.moveTo(spikeX, platform.y);
                                ctx.lineTo(spikeX + spikeType.width/2, platform.y - spikeType.height);
                                ctx.lineTo(spikeX + spikeType.width, platform.y);
                                ctx.lineTo(spikeX + spikeType.width/2, platform.y - spikeType.height/2);
                                ctx.fill();
                                break;
                            case 'ice':
                                // Draw crystal-like spike
                                ctx.beginPath();
                                ctx.moveTo(spikeX, platform.y);
                                ctx.lineTo(spikeX + spikeType.width/2, platform.y - spikeType.height);
                                ctx.lineTo(spikeX + spikeType.width, platform.y);
                                ctx.lineTo(spikeX + spikeType.width/2, platform.y - spikeType.height/3);
                                ctx.lineTo(spikeX, platform.y);
                                ctx.fill();
                                break;
                            case 'poison':
                                // Draw dripping spike
                                ctx.beginPath();
                                ctx.moveTo(spikeX, platform.y);
                                ctx.lineTo(spikeX + spikeType.width/2, platform.y - spikeType.height);
                                ctx.lineTo(spikeX + spikeType.width, platform.y);
                                ctx.lineTo(spikeX + spikeType.width/2, platform.y - spikeType.height/4);
                                ctx.lineTo(spikeX, platform.y);
                                ctx.fill();
                                break;
                            default:
                                // Draw normal spike
                                ctx.beginPath();
                                ctx.moveTo(spikeX, platform.y);
                                ctx.lineTo(spikeX + spikeType.width/2, platform.y - spikeType.height);
                                ctx.lineTo(spikeX + spikeType.width, platform.y);
                                ctx.fill();
                        }
                    }
                }

                // Draw duck body
                ctx.fillStyle = duck.color;
                ctx.fillRect(duck.x, duck.y, duck.width, duck.height);

                // Draw duck face
                ctx.fillStyle = '#000000';
                // Eye
                const eyeX = duck.facingRight ? duck.x + duck.width - 15 : duck.x + 15;
                ctx.beginPath();
                ctx.arc(eyeX, duck.y + 15, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // Beak
                ctx.fillStyle = '#FFA500';
                const beakX = duck.facingRight ? duck.x + duck.width : duck.x;
                ctx.beginPath();
                ctx.moveTo(beakX, duck.y + 20);
                ctx.lineTo(beakX + (duck.facingRight ? 10 : -10), duck.y + 25);
                ctx.lineTo(beakX, duck.y + 30);
                ctx.fill();

                // Draw active effects
                for (const effect of game.activeEffects) {
                    ctx.fillStyle = EFFECT_COLORS[effect];
                    ctx.fillRect(duck.x - 5, duck.y - 5, duck.width + 10, duck.height + 10);
                }

                // Draw health potions
                for (const potion of game.healthPotions) {
                    if (!potion.collected) {
                        // Draw potion bottle
                        ctx.fillStyle = HEALTH_POTION.color;
                        ctx.fillRect(potion.x, potion.y, potion.width, potion.height);
                        
                        // Draw potion cap
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(potion.x - 2, potion.y, potion.width + 4, 5);
                        
                        // Draw potion liquid
                        ctx.fillStyle = '#ff00ff';
                        ctx.fillRect(potion.x + 2, potion.y + 5, potion.width - 4, potion.height - 5);
                    }
                }

                ctx.restore();
            } catch (error) {
                console.error('Error in draw:', error);
            }
        }

        let lastFrameRequest = 0;
        function gameLoop(timestamp) {
            if (!game.running) return;

            try {
                // Prevent multiple frame requests
                if (timestamp - lastFrameRequest < 16) { // Cap at ~60 FPS
                    requestAnimationFrame(gameLoop);
                    return;
                }
                lastFrameRequest = timestamp;

                update();
                draw();
                requestAnimationFrame(gameLoop);
            } catch (error) {
                console.error('Error in gameLoop:', error);
                game.running = false;
                resetPlayer();
                game.running = true;
                requestAnimationFrame(gameLoop);
            }
        }

        // Initialize game
        window.addEventListener('load', () => {
            try {
                checkMobile();
                game.lastFrameTime = performance.now();
                initClouds();
                initMountains();
                resetPlayer();
                requestAnimationFrame(gameLoop);
            } catch (error) {
                console.error('Error starting game:', error);
                window.location.reload();
            }
        });

        // Update death handling
        function handleDeath() {
            game.running = false;
            if (game.score > game.highScore) {
                game.highScore = game.score;
                localStorage.setItem('highScore', game.highScore);
            }
            
            document.getElementById('deathScore').textContent = `Distance: ${game.score}m`;
            document.getElementById('highScore').textContent = `High Score: ${game.highScore}m`;
            document.getElementById('deathScreen').style.display = 'flex';
        }

        // Add restart button handler
        document.getElementById('restartButton').addEventListener('click', () => {
            document.getElementById('deathScreen').style.display = 'none';
            resetPlayer();
            game.running = true;
            requestAnimationFrame(gameLoop);
        });
    </script>
</body>
</html>
