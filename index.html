<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Duck Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: Arial, sans-serif;
        }
        #gameCanvas {
            background: #87CEEB;
            display: none;  /* Hide canvas initially */
            width: 100%;
            height: 100%;
            touch-action: none;  /* Prevent default touch actions */
        }
        #scoreBar {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 20px;
            color: white;
            font-size: 24px;
            font-family: Arial, sans-serif;
            text-shadow: 2px 2px 0 #000;
            z-index: 1000;
            display: none;
        }
        #titleScreen {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: #87CEEB;
            color: #000;
            z-index: 100;
        }
        #gameTitle {
            font-size: 72px;
            margin-bottom: 40px;
            text-shadow: 3px 3px 0 #fff;
            animation: bounce 1s infinite;
        }
        #instructions {
            font-size: 24px;
            margin-bottom: 30px;
            text-align: center;
            text-shadow: 2px 2px 0 #fff;
        }
        #startButton {
            padding: 20px 40px;
            font-size: 24px;
            background: #FFD700;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s;
        }
        #startButton:hover {
            transform: scale(1.1);
        }
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }
        #mobileControls {
            position: fixed;
            bottom: 20px;
            left: 0;
            right: 0;
            display: none;
            justify-content: center;
            align-items: center;
            gap: 20px;
            padding: 0 20px;
            z-index: 1000;
        }
        #moveArea {
            width: 40%;
            height: 80px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 40px;
            position: relative;
        }
        #jumpButton {
            width: 120px;
            height: 120px;
            background: rgba(255, 215, 0, 0.7);
            border: 3px solid #FFD700;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: #000;
            user-select: none;
            -webkit-user-select: none;
            cursor: pointer;
            transition: transform 0.1s, background-color 0.1s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            margin: 0 auto;
        }
        #jumpButton:active {
            background: rgba(255, 215, 0, 0.9);
            transform: scale(0.95);
        }
        #deathScreen {
            position: absolute;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            z-index: 1000;
        }
        #deathTitle {
            font-size: 72px;
            margin-bottom: 20px;
            color: #ff0000;
            text-shadow: 3px 3px 0 #000;
        }
        #deathScore {
            font-size: 36px;
            margin-bottom: 20px;
            color: #fff;
            text-shadow: 2px 2px 0 #000;
        }
        #highScore {
            font-size: 24px;
            margin-bottom: 30px;
            color: #ffd700;
            text-shadow: 2px 2px 0 #000;
        }
        #restartButton {
            padding: 20px 40px;
            font-size: 24px;
            background: #ff0000;
            border: none;
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
            transition: transform 0.2s;
        }
        #restartButton:hover {
            transform: scale(1.1);
        }
        #healthBar {
            position: fixed;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 20px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            z-index: 1000;
            display: none;
        }
        #healthFill {
            width: 100%;
            height: 100%;
            background: #00ff00;
            border-radius: 10px;
            transition: width 0.3s, background-color 0.3s;
        }
        #healthText {
            position: absolute;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 14px;
            text-shadow: 1px 1px 0 #000;
            line-height: 20px;
        }
        #healthRegenIndicator {
            position: absolute;
            right: -25px;
            top: 0;
            color: #00ff00;
            font-size: 16px;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }
        /* Mobile and iPad specific styles */
        @media (max-width: 1024px) {
            #mobileControls {
                gap: 30px;
            }
            #moveArea {
                width: 45%;
                height: 100px;
            }
            #jumpButton {
                width: 150px;
                height: 150px;
                font-size: 36px;
                border-width: 4px;
            }
        }
        /* iPhone specific styles */
        @media (max-width: 428px) {
            #mobileControls {
                gap: 20px;
            }
            #moveArea {
                width: 40%;
                height: 90px;
            }
            #jumpButton {
                width: 130px;
                height: 130px;
                font-size: 32px;
            }
        }
        /* iPad specific styles */
        @media (min-width: 768px) and (max-width: 1024px) {
            #mobileControls {
                gap: 40px;
            }
            #moveArea {
                width: 50%;
                height: 120px;
            }
            #jumpButton {
                width: 180px;
                height: 180px;
                font-size: 42px;
                border-width: 5px;
            }
        }
    </style>
</head>
<body>
    <div id="titleScreen">
        <h1 id="gameTitle">Duck Game</h1>
        <div id="instructions">
            Press SPACE or W to jump<br>
            Hold SPACE for consecutive jumps<br>
            <span id="mobileInstructions" style="display: none;">
                Use the joystick to move<br>
                Tap the yellow button to jump
            </span>
        </div>
        <button id="startButton">Start Game</button>
    </div>
    <div id="deathScreen">
        <h1 id="deathTitle">Game Over!</h1>
        <div id="deathScore">Distance: 0m</div>
        <div id="highScore">High Score: 0m</div>
        <button id="restartButton">Play Again</button>
    </div>
    <div id="scoreBar">Distance: 0m</div>
    <div id="healthBar">
        <div id="healthFill"></div>
        <div id="healthText">100 HP</div>
        <div id="healthRegenIndicator">+</div>
    </div>
    <div id="mobileControls">
        <div id="moveArea">
            <div id="moveKnob"></div>
        </div>
        <div id="jumpButton">JUMP</div>
    </div>
    <canvas id="gameCanvas"></canvas>
    <script>
        // Game constants
        const GRAVITY = 0.5;
        const JUMP_FORCE = 12;
        const MOVE_SPEED = 8;
        const FRICTION = 0.8;
        const PLATFORM_WIDTH = 120;
        const PLATFORM_HEIGHT = 20;
        const PLATFORM_MIN_Y = 100;
        const PLATFORM_MAX_Y = 350;
        const PLATFORM_SPACING = {
            min: 20,
            max: 40
        };

        // Game state
        const game = {
            health: 100,
            maxHealth: 100,
            score: 0,
            highScore: 0,
            isResetting: false,
            lastFrameTime: 0,
            frameCount: 0,
            healthPotions: [],
            lastDamageTime: 0,
            lastRegenTime: 0,
            regenInterval: 1000,
            regenAmount: 1,
            damageCooldown: 1000,
            running: false
        };

        // Duck object
        const duck = {
            startX: 50,
            startY: 300,
            x: 50,
            y: 300,
            width: 40,
            height: 40,
            speedX: 0,
            speedY: 0,
            facingRight: true,
            autoMove: true,
            isSpeedBoosted: false,
            speedBoostEndTime: 0,
            speedBoostActive: false,
            onGround: false
        };

        // Camera object
        const camera = {
            x: 0,
            y: 0
        };

        // Controls
        const controls = {
            left: false,
            right: false,
            jump: false
        };

        // Platforms array
        let platforms = [];

        // Start game function
        function startGame() {
            titleScreen.style.display = 'none';
            game.running = true;
            game.health = game.maxHealth;
            game.score = 0;
            game.isResetting = false;
            game.lastFrameTime = performance.now();
            game.frameCount = 0;
            game.healthPotions = [];
            game.lastDamageTime = 0;
            game.lastRegenTime = 0;

            // Reset duck
            duck.x = duck.startX;
            duck.y = duck.startY;
            duck.speedX = 0;
            duck.speedY = 0;
            duck.facingRight = true;
            duck.autoMove = true;
            duck.isSpeedBoosted = false;
            duck.speedBoostEndTime = 0;
            duck.speedBoostActive = false;
            duck.onGround = false;

            // Reset camera
            camera.x = 0;

            // Clear platforms
            platforms = [];

            // Generate initial platforms
            generatePlatforms(100);

            // Start game loop
            requestAnimationFrame(gameLoop);
        }

        // Game loop
        function gameLoop(timestamp) {
            if (!game.running) return;

            try {
                update();
                render();
                requestAnimationFrame(gameLoop);
            } catch (error) {
                console.error('Error in game loop:', error);
                game.running = false;
            }
        }

        // Update game state
        function update() {
            if (game.isResetting) return;

            try {
                const currentTime = performance.now();
                const deltaTime = currentTime - game.lastFrameTime;
                
                if (deltaTime > 100) {
                    console.warn('Severe lag detected, resetting...');
                    resetPlayer();
                    return;
                }

                game.lastFrameTime = currentTime;
                game.frameCount++;

                // Update score
                game.score = Math.floor(duck.x / 100);
                document.getElementById('scoreBar').textContent = `Distance: ${game.score}m`;

                // Movement
                if (duck.autoMove) {
                    duck.speedX = MOVE_SPEED;
                    duck.facingRight = true;
                } else {
                    if (controls.right) {
                        duck.speedX = MOVE_SPEED;
                        duck.facingRight = true;
                    } else if (controls.left) {
                        duck.speedX = -MOVE_SPEED;
                        duck.facingRight = false;
                    } else {
                        duck.speedX *= FRICTION;
                    }
                }

                // Physics
                duck.speedY += GRAVITY;
                if (controls.jump && duck.onGround) {
                    duck.speedY = -JUMP_FORCE;
                    duck.onGround = false;
                }

                // Update position
                duck.x += duck.speedX;
                duck.y += duck.speedY;

                // Death check
                if (duck.y > canvas.height) {
                    handleDeath();
                    return;
                }

                // Platform collision
                duck.onGround = false;
                for (const platform of platforms) {
                    if (!platform) continue;

                    if (duck.x < platform.x + platform.width &&
                        duck.x + duck.width > platform.x &&
                        duck.y + duck.height > platform.y &&
                        duck.y < platform.y + platform.height) {
                        duck.onGround = true;
                        duck.y = platform.y - duck.height;
                        duck.speedY = 0;
                    }
                }

                // Generate new platforms
                const lastPlatform = platforms[platforms.length - 1];
                if (!lastPlatform || lastPlatform.x < camera.x + canvas.width + 50) {
                    generatePlatforms(100);
                }

                // Camera update
                const targetX = Math.max(0, duck.x - canvas.width / 3);
                camera.x += (targetX - camera.x) * 0.15;

            } catch (error) {
                console.error('Error in update:', error);
                resetPlayer();
            }
        }

        // Generate platforms
        function generatePlatforms(count) {
            const lastPlatform = platforms[platforms.length - 1];
            const startX = lastPlatform ? lastPlatform.x + PLATFORM_SPACING.min : 0;

            // Clean up old platforms
            platforms = platforms.filter(p => p && p.x > camera.x - 100);

            // Generate new platforms
            for (let i = 0; i < count; i++) {
                const platform = {
                    x: startX + (i * PLATFORM_SPACING.min),
                    y: Math.random() * (PLATFORM_MAX_Y - PLATFORM_MIN_Y) + PLATFORM_MIN_Y,
                    width: PLATFORM_WIDTH,
                    height: PLATFORM_HEIGHT,
                    type: 'normal'
                };

                // Ensure platforms don't overlap vertically
                if (platforms.length > 0) {
                    const lastY = platforms[platforms.length - 1].y;
                    const minY = Math.max(PLATFORM_MIN_Y, lastY - 100);
                    const maxY = Math.min(PLATFORM_MAX_Y, lastY + 100);
                    platform.y = Math.random() * (maxY - minY) + minY;
                }

                platforms.push(platform);
            }
        }

        // Reset player
        function resetPlayer() {
            if (game.isResetting) return;
            game.isResetting = true;

            // Reset game state
            game.health = game.maxHealth;
            game.score = 0;
            game.lastDamageTime = 0;
            game.lastRegenTime = 0;
            game.healthPotions = [];

            // Reset duck
            duck.x = duck.startX;
            duck.y = duck.startY;
            duck.speedX = 0;
            duck.speedY = 0;
            duck.facingRight = true;
            duck.autoMove = true;
            duck.isSpeedBoosted = false;
            duck.speedBoostEndTime = 0;
            duck.speedBoostActive = false;
            duck.onGround = false;

            // Reset camera
            camera.x = 0;

            // Clear and regenerate platforms
            platforms = [];
            generatePlatforms(100);

            game.isResetting = false;
            game.running = true;
        }

        // Handle death
        function handleDeath() {
            if (game.isResetting) return;
            game.running = false;
            resetPlayer();
        }

        // Add start button handler
        startButton.addEventListener('click', startGame);

        // Add keyboard controls
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowRight':
                case 'd':
                    controls.right = true;
                    break;
                case 'ArrowLeft':
                case 'a':
                    controls.left = true;
                    break;
                case 'ArrowUp':
                case 'w':
                case ' ':
                    controls.jump = true;
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            switch(e.key) {
                case 'ArrowRight':
                case 'd':
                    controls.right = false;
                    break;
                case 'ArrowLeft':
                case 'a':
                    controls.left = false;
                    break;
                case 'ArrowUp':
                case 'w':
                case ' ':
                    controls.jump = false;
                    break;
            }
        });

        // Mobile controls
        const mobileControls = document.getElementById('mobileControls');
        const moveArea = document.getElementById('moveArea');
        const moveKnob = document.getElementById('moveKnob');
        const jumpButton = document.getElementById('jumpButton');
        const mobileInstructions = document.getElementById('mobileInstructions');
        let isMobile = false;

        // Check if device is mobile
        function checkMobile() {
            isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            if (isMobile) {
                mobileInstructions.style.display = 'block';
                mobileControls.style.display = 'flex';
            }
        }

        // Mobile touch controls
        let moveKnobActive = false;
        let moveKnobStartX = 0;
        let moveKnobStartY = 0;
        let moveKnobCurrentX = 0;

        moveKnob.addEventListener('touchstart', (e) => {
            e.preventDefault();
            moveKnobActive = true;
            const touch = e.touches[0];
            moveKnobStartX = touch.clientX;
            moveKnobStartY = touch.clientY;
            moveKnobCurrentX = moveKnob.offsetLeft;
        });

        document.addEventListener('touchmove', (e) => {
            if (!moveKnobActive) return;
            e.preventDefault();
            const touch = e.touches[0];
            const deltaX = touch.clientX - moveKnobStartX;
            const newX = Math.max(0, Math.min(moveArea.offsetWidth - moveKnob.offsetWidth, moveKnobCurrentX + deltaX));
            moveKnob.style.left = newX + 'px';
            
            // Update controls based on knob position
            const center = moveArea.offsetWidth / 2;
            const moveAmount = (newX - center) / center;
            controls.left = moveAmount < -0.2;
            controls.right = moveAmount > 0.2;
        });

        document.addEventListener('touchend', () => {
            moveKnobActive = false;
            moveKnob.style.left = '50%';
            moveKnob.style.transform = 'translateX(-50%)';
            controls.left = false;
            controls.right = false;
        });

        jumpButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            controls.jump = true;
        });

        jumpButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            controls.jump = false;
        });

        // Prevent default touch behaviors
        document.addEventListener('touchmove', (e) => {
            if (e.target === canvas || e.target === moveArea || e.target === moveKnob || e.target === jumpButton) {
                e.preventDefault();
            }
        }, { passive: false });

        // Set canvas size
        function setCanvasSize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        // Initial setup
        setCanvasSize();
        window.addEventListener('resize', setCanvasSize);

        // Add clouds
        const clouds = [];
        const CLOUD_COUNT = 10;
        const CLOUD_SPEED = 0.2;

        function initClouds() {
            for (let i = 0; i < CLOUD_COUNT; i++) {
                const cloudType = getRandomType(CLOUD_TYPES);
                if (cloudType === 'none') continue;

                clouds.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * (canvas.height / 2),
                    width: 60 + Math.random() * 40,
                    height: 30 + Math.random() * 20,
                    type: cloudType
                });
            }
        }

        function updateClouds() {
            for (const cloud of clouds) {
                cloud.x -= CLOUD_SPEED;
                if (cloud.x + cloud.width < 0) {
                    cloud.x = canvas.width;
                    cloud.y = Math.random() * (canvas.height / 2);
                }
            }
        }

        function drawCloud(x, y, width, height, type) {
            const cloudData = CLOUD_TYPES[type];
            if (!cloudData || !cloudData.color) return;

            ctx.fillStyle = cloudData.color;
            ctx.beginPath();
            ctx.arc(x, y, width/3, 0, Math.PI * 2);
            ctx.arc(x + width/3, y - height/4, width/4, 0, Math.PI * 2);
            ctx.arc(x + width/2, y, width/3, 0, Math.PI * 2);
            ctx.arc(x + width/3, y + height/4, width/4, 0, Math.PI * 2);
            ctx.fill();

            // Add effects based on cloud type
            if (type === 'thunder') {
                // Draw lightning
                if (Math.random() < 0.1) {
                    ctx.strokeStyle = '#FFFF00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x + width/2, y + height);
                    ctx.lineTo(x + width/2, y + height + 30);
                    ctx.stroke();
                }
            } else if (type === 'rain') {
                // Draw rain
                ctx.strokeStyle = 'rgba(200, 200, 255, 0.5)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 5; i++) {
                    const rainX = x + (width * i / 4);
                    ctx.beginPath();
                    ctx.moveTo(rainX, y + height);
                    ctx.lineTo(rainX - 5, y + height + 15);
                    ctx.stroke();
                }
            } else if (type === 'tornado') {
                // Draw tornado
                ctx.strokeStyle = 'rgba(100, 100, 100, 0.8)';
                ctx.lineWidth = 2;
                const centerX = x + width/2;
                const centerY = y + height/2;
                const radius = Math.min(width, height) / 2;
                
                // Draw spiral
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius - i * 10, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Draw debris
                for (let i = 0; i < 5; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const debrisX = centerX + Math.cos(angle) * radius;
                    const debrisY = centerY + Math.sin(angle) * radius;
                    ctx.fillStyle = 'rgba(139, 69, 19, 0.8)';
                    ctx.fillRect(debrisX - 2, debrisY - 2, 4, 4);
                }
            } else if (type === 'nuke') {
                // Draw mushroom cloud
                ctx.fillStyle = 'rgba(255, 0, 0, 0.6)';
                ctx.beginPath();
                ctx.arc(x + width/2, y + height/2, width/2, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw stem
                ctx.fillStyle = 'rgba(255, 69, 0, 0.8)';
                ctx.fillRect(x + width/2 - 10, y + height/2, 20, 30);
                
                // Draw radiation symbol
                ctx.strokeStyle = '#FFFF00';
                ctx.lineWidth = 2;
                const centerX = x + width/2;
                const centerY = y + height/2;
                for (let i = 0; i < 3; i++) {
                    const angle = (i * Math.PI * 2) / 3;
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(
                        centerX + Math.cos(angle) * 15,
                        centerY + Math.sin(angle) * 15
                    );
                    ctx.stroke();
                }
            } else if (type === 'bread') {
                // Draw bread slices
                for (let i = 0; i < 5; i++) {
                    const breadX = x + (width * i / 4);
                    ctx.fillStyle = '#DEB887';
                    ctx.beginPath();
                    ctx.ellipse(breadX, y + height + 10, 8, 4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw crust
                    ctx.strokeStyle = '#8B4513';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.ellipse(breadX, y + height + 10, 8, 4, 0, 0, Math.PI * 2);
                    ctx.stroke();
                }
            } else if (type === 'cloudPerson') {
                // Draw face
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                // Eyes
                ctx.beginPath();
                ctx.arc(x + width/2 - 10, y - 5, 5, 0, Math.PI * 2);
                ctx.arc(x + width/2 + 10, y - 5, 5, 0, Math.PI * 2);
                ctx.fill();
                // Smile
                ctx.beginPath();
                ctx.arc(x + width/2, y + 5, 10, 0, Math.PI);
                ctx.stroke();

                // Draw limbs
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.lineWidth = 3;
                // Arms
                ctx.beginPath();
                ctx.moveTo(x + width/2 - 20, y);
                ctx.lineTo(x + width/2 - 40, y + 20);
                ctx.moveTo(x + width/2 + 20, y);
                ctx.lineTo(x + width/2 + 40, y + 20);
                ctx.stroke();
                // Legs
                ctx.beginPath();
                ctx.moveTo(x + width/2 - 10, y + height/2);
                ctx.lineTo(x + width/2 - 20, y + height/2 + 30);
                ctx.moveTo(x + width/2 + 10, y + height/2);
                ctx.lineTo(x + width/2 + 20, y + height/2 + 30);
                ctx.stroke();
            } else if (type === 'gemCloud') {
                // Draw sparkling gems
                const gemColors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF'];
                for (let i = 0; i < 8; i++) {
                    const angle = (i * Math.PI * 2) / 8;
                    const gemX = x + width/2 + Math.cos(angle) * width/3;
                    const gemY = y + height/2 + Math.sin(angle) * height/3;
                    
                    // Draw gem
                    ctx.fillStyle = gemColors[i % gemColors.length];
                    ctx.beginPath();
                    ctx.moveTo(gemX, gemY - 8);
                    ctx.lineTo(gemX + 6, gemY);
                    ctx.lineTo(gemX, gemY + 8);
                    ctx.lineTo(gemX - 6, gemY);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Add sparkle
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(gemX - 10, gemY);
                    ctx.lineTo(gemX + 10, gemY);
                    ctx.moveTo(gemX, gemY - 10);
                    ctx.lineTo(gemX, gemY + 10);
                    ctx.stroke();
                }
                
                // Add rainbow aura
                const gradient = ctx.createRadialGradient(
                    x + width/2, y + height/2, 0,
                    x + width/2, y + height/2, width
                );
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
                gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.2)');
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x + width/2, y + height/2, width, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Update health bar
        function updateHealthBar() {
            const healthBar = document.getElementById('healthBar');
            const healthFill = document.getElementById('healthFill');
            const healthText = document.getElementById('healthText');
            const healthRegenIndicator = document.getElementById('healthRegenIndicator');
            
            const healthPercent = (game.health / game.maxHealth) * 100;
            healthFill.style.width = `${healthPercent}%`;
            healthText.textContent = `${Math.ceil(game.health)} HP`;

            // Change color based on health
            if (healthPercent > 60) {
                healthFill.style.backgroundColor = '#00ff00';
            } else if (healthPercent > 30) {
                healthFill.style.backgroundColor = '#ffff00';
            } else {
                healthFill.style.backgroundColor = '#ff0000';
            }

            // Show/hide regen indicator only if not in damage cooldown
            const currentTime = performance.now();
            const canRegen = currentTime - game.lastDamageTime >= game.damageCooldown;
            healthRegenIndicator.style.display = (game.health < game.maxHealth && canRegen) ? 'block' : 'none';
        }

        // Heal function
        function heal(amount) {
            game.health = Math.min(game.maxHealth, game.health + amount);
            updateHealthBar();
        }

        // Take damage function
        function takeDamage(amount, effect = null) {
            if (game.invulnerable) return;
            
            game.health = Math.max(0, game.health - amount);
            game.lastDamageTime = performance.now(); // Update last damage time
            updateHealthBar();

            // Apply effects
            if (effect) {
                switch(effect) {
                    case 'burn':
                        // Take additional damage over time
                        let burnDamage = amount * 0.2;
                        for (let i = 0; i < 5; i++) {
                            setTimeout(() => {
                                game.health = Math.max(0, game.health - burnDamage);
                                game.lastDamageTime = performance.now(); // Update on each burn tick
                                updateHealthBar();
                            }, i * 1000);
                        }
                        break;
                    case 'freeze':
                        // Slow down movement temporarily
                        const originalMoveSpeed = MOVE_SPEED;
                        MOVE_SPEED *= 0.5;
                        setTimeout(() => {
                            MOVE_SPEED = originalMoveSpeed;
                        }, 3000);
                        break;
                    case 'poison':
                        // Take small damage over time
                        let poisonDamage = amount * 0.1;
                        for (let i = 0; i < 10; i++) {
                            setTimeout(() => {
                                game.health = Math.max(0, game.health - poisonDamage);
                                game.lastDamageTime = performance.now(); // Update on each poison tick
                                updateHealthBar();
                            }, i * 1000);
                        }
                        break;
                }
            }

            // Check for death
            if (game.health <= 0) {
                handleDeath();
                return;
            }

            // Temporary invulnerability
            game.invulnerable = true;
            game.invulnerabilityTime = performance.now() + 1000; // 1 second invulnerability
        }

        // Render function
        function render() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Save context for camera transform
            ctx.save();
            ctx.translate(-camera.x, 0);

            // Draw background
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw platforms
            for (const platform of platforms) {
                if (!platform) continue;

                // Draw platform
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(platform.x, platform.y, platform.width, platform.height);

                // Draw platform top
                ctx.fillStyle = '#A0522D';
                ctx.fillRect(platform.x, platform.y, platform.width, 5);

                // Draw spikes if platform has them
                if (platform.hasSpikes) {
                    ctx.fillStyle = '#FF0000';
                    ctx.beginPath();
                    ctx.moveTo(platform.spikeX, platform.y);
                    ctx.lineTo(platform.spikeX + 20, platform.y - 15);
                    ctx.lineTo(platform.spikeX + 40, platform.y);
                    ctx.fill();
                }
            }

            // Draw duck
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(duck.x, duck.y, duck.width, duck.height);

            // Draw duck face
            ctx.fillStyle = '#000000';
            if (duck.facingRight) {
                // Right eye
                ctx.fillRect(duck.x + 30, duck.y + 10, 5, 5);
                // Beak
                ctx.fillRect(duck.x + 35, duck.y + 15, 10, 5);
            } else {
                // Left eye
                ctx.fillRect(duck.x + 5, duck.y + 10, 5, 5);
                // Beak
                ctx.fillRect(duck.x - 5, duck.y + 15, 10, 5);
            }

            // Draw health potions
            for (const potion of game.healthPotions) {
                if (!potion.collected) {
                    ctx.fillStyle = '#FF0000';
                    ctx.fillRect(potion.x, potion.y, potion.width, potion.height);
                }
            }

            // Restore context
            ctx.restore();

            // Draw UI elements (not affected by camera)
            // Health bar
            const healthBarWidth = 200;
            const healthBarHeight = 20;
            const healthBarX = 20;
            const healthBarY = 20;

            // Health bar background
            ctx.fillStyle = '#FF0000';
            ctx.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);

            // Health bar fill
            ctx.fillStyle = '#00FF00';
            ctx.fillRect(healthBarX, healthBarY, (game.health / game.maxHealth) * healthBarWidth, healthBarHeight);

            // Health bar border
            ctx.strokeStyle = '#000000';
            ctx.strokeRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);

            // Score
            ctx.fillStyle = '#000000';
            ctx.font = '20px Arial';
            ctx.fillText(`Distance: ${game.score}m`, 20, 60);
        }

        let lastFrameRequest = 0;
        function gameLoop(timestamp) {
            if (!game.running) return;

            try {
                // Prevent multiple frame requests
                if (timestamp - lastFrameRequest < 16) { // Cap at ~60 FPS
                    requestAnimationFrame(gameLoop);
                    return;
                }
                lastFrameRequest = timestamp;

                update();
                render();
                requestAnimationFrame(gameLoop);
            } catch (error) {
                console.error('Error in gameLoop:', error);
                game.running = false;
                resetPlayer();
                game.running = true;
                requestAnimationFrame(gameLoop);
            }
        }

        // Initialize game
        window.addEventListener('load', () => {
            try {
                checkMobile();
                game.lastFrameTime = performance.now();
                initClouds();
                initMountains();
                resetPlayer();
                requestAnimationFrame(gameLoop);
            } catch (error) {
                console.error('Error starting game:', error);
                window.location.reload();
            }
        });

        // Add restart button handler
        document.getElementById('restartButton').addEventListener('click', () => {
            document.getElementById('deathScreen').style.display = 'none';
            resetPlayer();
            game.running = true;
            requestAnimationFrame(gameLoop);
        });
    </script>
</body>
</html>
